import cv2
import numpy as np
import os
import shutil
import random
import mrcfile


def shift(img, x, y):
    '''
    Shift image.

    Args:
        img: image in ndarray
        x: tranlation pixels in x axis (down direction as positive direction)
        y: tranlation pixels in y axis (right direction as positive direction)

    Returns:
        translated image in ndarray
    '''
    if x == 0 and y == 0:
        return img
    m = np.min(img)
    cols, rows = img.shape
    img = img - m
    matrix = np.float32([[1, 0, y], [0, 1, x]])
    img = cv2.warpAffine(img, matrix, (cols, rows), borderMode=cv2.BORDER_WRAP)
    img += m
    return img


def shift_mask(img, x, y):
    '''
    Mask generated by translations. (the only difference is padding mode)

    Args:
        img: image in ndarray
        x: tranlation pixels in x axis (down direction as positive direction)
        y: tranlation pixels in y axis (right direction as positive direction)

    Returns:
        generated Mask in ndarray
    '''
    if x == 0 and y == 0:
        return img
    m = np.min(img)
    cols, rows = img.shape
    img = img - m
    matrix = np.float32([[1, 0, y], [0, 1, x]])
    img = cv2.warpAffine(img, matrix, (cols, rows), borderMode=cv2.BORDER_CONSTANT)
    img += m
    return img


def rotate(img, ang):
    '''
    Rotate image.

    Args:
        img: image in ndarray
        ang: rotation angle in degree (counterclockwise as positive direction)
        center: coordinate of rotation center

    Returns:
        rotated image in ndarray
    '''
    m = np.min(img)
    cols, rows = img.shape
    img = img - m
    matrix = cv2.getRotationMatrix2D((cols / 2, rows / 2), ang, 1)
    img = cv2.warpAffine(img, matrix, (cols, rows), borderMode=cv2.BORDER_WRAP)
    img += m
    return img


def rotate_mask(img, ang):
    '''
    Mask generated by rotation. (the only difference is padding mode)

    Args:
        img: image in ndarray
        ang: rotation angle in degree (counterclockwise as positive direction)
        center: coordinate of rotation center

    Returns:
        generated Mask in ndarray
    '''
    m = np.min(img)
    cols, rows = img.shape
    img = img - m
    matrix = cv2.getRotationMatrix2D((cols / 2, rows / 2), ang, 1)
    img = cv2.warpAffine(img, matrix, (cols, rows), borderMode=cv2.BORDER_CONSTANT)
    img += m
    return img


def gauss_noise(img, var=-1):
    '''
    Add Gaussian noise to image.

    Args:
        img: image in ndarray
        var: variaration rate of Gaussian noise added to image

    Returns:
        Gaussian noisy image in ndarray
    '''
    mean = 0
    if var == -1:
        var = np.var(img) * 10
    else:
        var = np.var(img) * var
    noise = np.random.normal(mean, var**0.5, img.shape)
    out = img + noise
    return out


def ctf(k):
    '''
    CTF function.

    Args:
        k: Fourier frequency

    Returns:
        corresponding CTF value
    '''
    voltage = 300 * 1e3
    B_factor = 50
    Cs = 2.7 * 1e7
    defocus = 1.0 * 1e4
    amplitude_contrast = 0.07
    relativistic_lambda = 12.2643247 / np.sqrt(voltage * (1 + voltage * 0.978466e-6))
    gamma = (-np.pi / 2) * Cs * np.power(relativistic_lambda, 3) * np.power(
        k, 4) + np.pi * relativistic_lambda * defocus * np.power(k, 2)  # Zhang 2016
    CTF = -np.sqrt(1 - np.power(amplitude_contrast, 2)) * np.sin(gamma) - amplitude_contrast * np.cos(
        gamma)  # CTF=-sqrt(1-A^2)Sin(gamma) - A cos(gamma); Zhang 2016
    k_squared = np.power(k, 2)
    E = np.exp(-1 * B_factor * k_squared)  # generalised B-factor; Frank, 2006
    Y = CTF * E
    return Y


def apply_ctf(img, pixel_size):
    '''
    Apply CTF function to images.

    Args:
        img: input image in ndarray
        pixel_size: pixel size of image

    Returns:
        image with CTF affection
    '''
    img_f = np.fft.fft2(img)
    img_f = np.fft.fftshift(img_f)
    c0 = int(img_f.shape[0] / 2)
    c1 = int(img_f.shape[1] / 2)
    for i in range(img_f.shape[0]):
        for j in range(img_f.shape[1]):
            d = np.sqrt((i - c0)**2 + (j - c1)**2)
            img_f[i, j] *= ctf(d / pixel_size / 128)
    img_f = np.fft.ifftshift(img_f)
    img_n = np.fft.ifft2(img_f).real
    m1 = np.min(img_n)
    m2 = np.max(img_n)
    img_n = (img_n - m1) / (m2 - m1) * 255
    return img_n


def to_array(img):
    '''
    Adjust image range to [0,255]

    Args:
        img: image in ndarray

    Returns:
        adjusted image in ndarray
    '''
    if np.max(img) != np.min(img):
        img = (img - np.min(img)) / (np.max(img) - np.min(img))
        img = np.array(img * 255, dtype=np.uint8)
    return img


def write_mrc(img, path):
    '''
    Write image stack into MRC file

    Args:
        img: image in ndarray
        path: output path of MRC file
    '''
    if os.path.exists(path):
        os.remove(path)
    new_mrc = mrcfile.new(path)
    new_mrc.set_data(img)
    new_mrc.close()


def generate_data_all(img, path, pixel_size):
    '''
    Generate synthetic cryo-EM dataset of 50k images.

    Args:
        img: picked particle from class center images
        path: path to generated dataset
    '''
    n = 50000
    img_ori = img
    out_path_clean = path + "clean/"
    if os.path.exists(out_path_clean):
        shutil.rmtree(out_path_clean)
    os.mkdir(out_path_clean)
    one_path_clean = out_path_clean + "one_png/"
    os.mkdir(one_path_clean)
    txt_path_clean = out_path_clean + "parameters.txt"
    f_clean = open(txt_path_clean, 'w')

    out_path_noise = path + "noise/"
    if os.path.exists(out_path_noise):
        shutil.rmtree(out_path_noise)
    os.mkdir(out_path_noise)
    one_path_noise = out_path_noise + "one_png/"
    os.mkdir(one_path_noise)
    txt_path_noise = out_path_noise + "parameters.txt"
    f_noise = open(txt_path_noise, 'w')

    stack_clean = []
    stack_noise = []

    for i in range(n):
        data = img_ori
        ang = random.uniform(0, 360)
        shift_x = random.randint(-10, 10)
        shift_y = random.randint(-10, 10)
        img = rotate(data, ang)
        img = shift(img, shift_x, shift_y).astype(np.float32)
        cv2.imwrite(one_path_clean + str(i).zfill(len(str(n))) + '.png', to_array(img))
        stack_clean.append(to_array(img))
        img = gauss_noise(img, 1 / 1.4).astype(np.float32)
        img = apply_ctf(img, pixel_size)
        img = gauss_noise(img, 10).astype(np.float32)
        cv2.imwrite(one_path_noise + str(i).zfill(len(str(n))) + '.png', to_array(img))
        stack_noise.append(to_array(img))

        f_clean.write(str(i) + ' ' + str(ang) + ' ' + str(shift_x) + ' ' + str(shift_y) + '\n')
        f_noise.write(str(i) + ' ' + str(ang) + ' ' + str(shift_x) + ' ' + str(shift_y) + '\n')

    f_clean.close()
    f_noise.close()
    stack_clean = np.array(stack_clean, dtype=np.float32)
    stack_noise = np.array(stack_noise, dtype=np.float32)
    write_mrc(stack_clean, out_path_clean + 'stack.mrcs')
    write_mrc(stack_noise, out_path_noise + 'stack.mrcs')


if __name__ == '__main__':
    path = '/path/to/particles/'  # folder 'cryo-em centers' in Supplementary File

    pixel_size_g = [2.08, 2, 1.23, 1.42, 2.8]

    for i in range(5):
        index = i + 1
        path_i = path + str(index) + '/'
        img = cv2.imread(path_i + 'ori.png')
        img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)

        pixel_size = pixel_size_g[i]
        if img.shape[0] != 128:
            pixel_size = 128 / img.shape[0] * pixel_size
            img = cv2.resize(img, (128, 128))

        generate_data_all(img, path_i, pixel_size)
